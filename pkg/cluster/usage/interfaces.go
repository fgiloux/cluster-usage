/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package usage

import (
	"fmt"

	corev1 "k8s.io/api/core/v1"
	// "k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/tools/cache"
)

type SelectorType int8

const (
	LabelSelector SelectorType = iota
	// FGI TODO: not implementing FieldSelector for now.
	// I am not sure of the impact of it on the use of metadata vs type informers
	// FieldSelector
)

type EventType int

func (e EventType) String() string {
	switch e {
	case AddEvent:
		return "add"
	case UpdateEvent:
		return "update"
	case DeleteEvent:
		return "delete"
	default:
		return fmt.Sprintf("unknown(%d)", int(e))
	}
}

const (
	AddEvent EventType = iota
	UpdateEvent
	DeleteEvent
)

type Event struct {
	EventType EventType
	Obj       interface{}
	OldObj    interface{}
	GR        schema.GroupResource
}

// FGI TODO: may be removed
type UsageStatsOptions struct {
	// Namespace where stats should be calculated
	Namespace string
	// Scopes that must match counted objects
	Scopes []corev1.ResourceQuotaScope
	// Resources are the set of resources to include in the measurement
	Resources     []corev1.ResourceName
	ScopeSelector *corev1.ScopeSelector
}

// FGI TODO: may be removed
// UsageStats is result of measuring observed resource use in the system
type UsageStats struct {
	// Used maps resource to quantity used
	Used corev1.ResourceList
}

// Measure is the measure of resources use in the system
type Measure struct {
	// Used maps resources (CPU, memory, etc) to quantity used
	Used corev1.ResourceList
	// Count tracks the number of objects
	Count int32
}

// UsageRequest is a request for tracking some specific usage
type UsageRequest struct {
	// GroupResource to track
	GroupResource schema.GroupResource
	// PerNamespace specifies whether the accounting needs to be done per namespace
	PerNamespace bool
	// Filter is a filter which is a metav1.ListOptions compatible expression
	Filter string
	// FilterType is the type of filter: either LabelSelector or FieldSelector (nil if no filter)
	FilterType SelectorType
	// Threshold is the percentage of increase or decrease triggering a notification
	Threshold int16
	// Notifier is a channel, where the new result gets notified
	// FGI TODO: I may want to send a Response rather than a Measurer
	// A Response generated by a Measurer would be a struct containing an array of Measures and the GroupResource
	Notifier chan *UsageResponse
}

// UsageResponse is a response for a specific GroupResource
type UsageResponse struct {
	// GroupResource of the measures
	GroupResource schema.GroupResource
	// Measures is a map of the measures for each namespace
	// metav1.NamespaceAll is used as key for cluster scoped resources
	Measures map[string]Measure
}

// Measurer => Evaluator provides the values for a specific request
// FGI TODO: I believe that Measurer and Evaluator will end up being the same thing
// I should then rename my specific code to use "Evaluator" as name instead
// The main difference is that my code stores the values instead of using a quota resource for it
// How does it impact memory consumption? Would it be better just to have a 5mns polling?
// We support 10k namespaces. If we track 5 k8 resources with some of them having multiple resources
// we may have 10 measures. Let's say between name and value we use 128 bits/16 bytes for 1 measure.
// 16*10*10k~=1.5MiB. This should be OK?
// This does not however account for the sharedInformer...
// Evaluator knows how to track usage for a particular group resource
type Evaluator interface {
	GroupResource() schema.GroupResource
	// Usage returns either the cluster scoped usage or the aggregated measures for the resource
	Usage() Measure
	// NamespacedUsage returns the usage of the resource for the specified namespace. Same as Usage for cluster scoped resources.
	NamespacedUsage(namespace string) Measure
	// Recalculate refreshes the measures for the specified resource and namespace
	Recalculate(namespace string, groupResource schema.GroupResource) map[string]Measure
	// ProcessChange updates the usage with the change event and returns the new state (a map of measures indexed by namespaces)
	ProcessChange(event *Event) map[string]Measure
}

// Processor knows how to calculate new usage
type Processor interface {
	// Recalculate refreshes the measures for the specified resource and namespace
	Recalculate(measures Measure, namespace string, groupResource schema.GroupResource) Measure
	// ProcessChange processes the measures with the change event and returns the new state
	ProcessChange(measures Measure, event *Event) Measure
}

// Evaluator knows how to report usage for a particular group resource
/* type Evaluator interface {
	// TODO: is this needed?
	// Constraints ensures that each required resource is present on item
	Constraints(required []corev1.ResourceName, item runtime.Object) error
	// GroupResource returns the groupResource that this object knows how to evaluate
	GroupResource() schema.GroupResource
	// Usage returns the resource usage for the specified object
	// Matches returns true if the specified quota matches the input item
	// Matches(resourceQuota *corev1.ResourceQuota, item runtime.Object) (bool, error)
	// MatchingScopes takes the input specified list of scopes and input object and returns the set of scopes that matches input object.
	// MatchingScopes(item runtime.Object, scopes []corev1.ScopedResourceSelectorRequirement) ([]corev1.ScopedResourceSelectorRequirement, error)
	// UncoveredQuotaScopes takes the input matched scopes which are limited by configuration and the matched quota scopes. It returns the scopes which are in limited scopes but don't have a corresponding covering quota scope
	// UncoveredQuotaScopes(limitedScopes []corev1.ScopedResourceSelectorRequirement, matchedQuotaScopes []corev1.ScopedResourceSelectorRequirement) ([]corev1.ScopedResourceSelectorRequirement, error)
	// MatchingResources takes the input specified list of resources and returns the set of resources evaluator matches.
	MatchingResources(input []corev1.ResourceName) []corev1.ResourceName
	// Usage returns the resource usage for the specified object
	Usage(item runtime.Object) (corev1.ResourceList, error)
	// UsageStats calculates latest observed usage stats for all objects
	UsageStats(options UsageStatsOptions) (UsageStats, error)
}*/

// Configuration defines how the quota system is configured.
type Configuration interface {
	//resources whose usage is tracked.
	// FGI TODO: I should not need that
	// IgnoredResources() map[schema.GroupResource]struct{}
	// Evaluators for usage reporting.
	Evaluators() []Evaluator
}

// Registry maintains a list of evaluators
type Registry interface {
	// Add to registry
	Add(e Evaluator)
	// Remove from registry
	Remove(e Evaluator)
	// Get by group resource
	Get(gr schema.GroupResource) Evaluator
	// List from registry
	List() []Evaluator
}

// ListerForResourceFunc knows how to get a lister for a specific resource
type ListerForResourceFunc func(schema.GroupVersionResource) (cache.GenericLister, error)
